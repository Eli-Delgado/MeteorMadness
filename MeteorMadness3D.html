<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>Simulador de Impacto Meteoro - Tierra Azul con Atm√≥sfera</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
    canvas { display: block; }
    #controls {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(0,0,0,0.7);
      padding: 12px;
      border-radius: 8px;
      color: #fff;
      font-size: 13px;
      z-index: 10;
      max-width: 300px;
    }
    input { width: 80px; margin: 2px; }
    button {
      margin-top: 6px;
      padding: 5px 10px;
      background: orange;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
    }
    #results {
      margin-top: 10px;
      font-size: 12px;
      line-height: 1.3em;
      max-height: 220px;
      overflow-y: auto;
    }
    #chartContainer {
      margin-top: 10px;
    }
  </style>
</head>
<body>
<div id="controls">
  <b>Par√°metros del impacto:</b><br>
  Latitud: <input type="number" id="lat" value="0"><br>
  Longitud: <input type="number" id="lon" value="0"><br>
  Di√°metro (m): <input type="number" id="diam" value="100"><br>
  Densidad (kg/m¬≥): <input type="number" id="rho" value="3000"><br>
  Velocidad (km/s): <input type="number" id="vel" value="20"><br>
  Eficiencia s√≠smica: <input type="number" step="0.0001" id="eff" value="0.001"><br>
  Profundidad (km): <input type="number" id="depth" value="10"><br>
  <button id="simulateBtn">Simular meteoro</button>
  <div id="results"></div>
  <div id="chartContainer">
    <canvas id="energyChart" width="260" height="180"></canvas>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
  // === Escena ===
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.z = 3;
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  const controls = new THREE.OrbitControls(camera, renderer.domElement);

  // === Luces ===
  scene.add(new THREE.AmbientLight(0x404040));
  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(5,5,5);
  scene.add(directionalLight);

  // === Tierra ===
  const RADIUS = 1.0;
  const earth = new THREE.Mesh(
    new THREE.SphereGeometry(RADIUS, 64, 64),
    new THREE.MeshPhongMaterial({ color: 0x2266ff, shininess: 40 })
  );
  scene.add(earth);

  // === Atm√≥sfera ===
  const atmosphere = new THREE.Mesh(
    new THREE.SphereGeometry(RADIUS * 1.05, 64, 64),
    new THREE.MeshPhongMaterial({
      color: 0x3399ff,
      transparent: true,
      opacity: 0.15,
      side: THREE.DoubleSide
    })
  );
  scene.add(atmosphere);

  // === Meteoro ===
  const textureLoader = new THREE.TextureLoader();
  const meteorTexture = textureLoader.load("https://threejsfundamentals.org/threejs/resources/images/comet.jpg");
  const meteoro = new THREE.Mesh(
    new THREE.SphereGeometry(0.05, 32, 32),
    new THREE.MeshPhongMaterial({ map: meteorTexture })
  );
  meteoro.visible = false;
  scene.add(meteoro);

  // üî• Glow m√°s intenso del meteoro
  const meteoroGlow = new THREE.Mesh(
    new THREE.SphereGeometry(0.08, 32, 32),
    new THREE.MeshBasicMaterial({ color: 0xff9933, transparent: true, opacity: 0.9 })
  );
  meteoroGlow.visible = false;
  scene.add(meteoroGlow);

  // === Flash del impacto ===
  const flash = new THREE.Mesh(
    new THREE.SphereGeometry(0.12, 32, 32),
    new THREE.MeshBasicMaterial({ color: 0xffffaa, transparent: true, opacity: 0 })
  );
  flash.visible = false;
  scene.add(flash);

  // === Grupos ===
  const ringsGroup = new THREE.Group(); scene.add(ringsGroup);
  const graticuleGroup = new THREE.Group(); scene.add(graticuleGroup);

  // === Graticule ===
  function drawGraticule(stepLat=30, stepLon=30) {
    const material = new THREE.LineBasicMaterial({ color: 0x888888 });
    for (let lat=-90; lat<=90; lat+=stepLat) {
      const points=[];
      for (let lon=0; lon<=360; lon+=5) {
        const phi=THREE.MathUtils.degToRad(lat);
        const theta=THREE.MathUtils.degToRad(lon);
        points.push(new THREE.Vector3(
          RADIUS*Math.cos(phi)*Math.cos(theta),
          RADIUS*Math.sin(phi),
          RADIUS*Math.cos(phi)*Math.sin(theta)
        ));
      }
      graticuleGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), material));
    }
    for (let lon=0; lon<360; lon+=stepLon) {
      const points=[];
      for (let lat=-90; lat<=90; lat+=5) {
        const phi=THREE.MathUtils.degToRad(lat);
        const theta=THREE.MathUtils.degToRad(lon);
        points.push(new THREE.Vector3(
          RADIUS*Math.cos(phi)*Math.cos(theta),
          RADIUS*Math.sin(phi),
          RADIUS*Math.cos(phi)*Math.sin(lon)
        ));
      }
      graticuleGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), material));
    }
  }
  drawGraticule();

  // === Utilidades ===
  function latLonToVector3(latDeg, lonDeg, radius) {
    const lat = THREE.MathUtils.degToRad(latDeg);
    const lon = THREE.MathUtils.degToRad(lonDeg);
    return new THREE.Vector3(
      radius*Math.cos(lat)*Math.cos(lon),
      radius*Math.sin(lat),
      radius*Math.cos(lat)*Math.sin(lon)
    );
  }
  function mwEquivalente(d_m, rho, v_ms, eficiencia) {
    const volumen=(Math.PI/6.0)*Math.pow(d_m,3);
    const masa=rho*volumen;
    const E_k=0.5*masa*v_ms*v_ms;
    const E_s=eficiencia*E_k;
    const Mw=(Math.log10(E_s)-4.8)/1.5;
    return { Mw, masa, E_k, E_s };
  }
  function mmiIPE(mw, r_km, depth_km, a=1.5,b=1.6,c=3.0,d=10.0) {
    const R=Math.sqrt(r_km*r_km+depth_km*depth_km);
    return a+b*mw-c*Math.log10(R+d);
  }
  function radioParaMMI(mw,mmi_obj,depth_km=10.0) {
    let mmi_centro=mmiIPE(mw,0.0,depth_km);
    if(mmi_centro<mmi_obj) return null;
    let lo=0,hi=2000;
    for(let i=0;i<60;i++){const mid=(lo+hi)/2; const m=mmiIPE(mw,mid,depth_km); if(m>=mmi_obj) lo=mid; else hi=mid;}
    return (lo+hi)/2;
  }
  function drawRing(lat, lon, radiusKm, color) {
    if (!radiusKm) return;
    const EARTH_R_KM=6371;
    const circleRadius=RADIUS*(radiusKm/EARTH_R_KM);
    const points=[];
    for(let i=0;i<=64;i++){
      const angle=(i/64)*Math.PI*2;
      const x=Math.cos(angle)*circleRadius;
      const y=Math.sin(angle)*circleRadius;
      const vec=new THREE.Vector3(x,y,0);
      const axis=new THREE.Vector3(0,0,1);
      const target=latLonToVector3(lat,lon,RADIUS);
      const quaternion=new THREE.Quaternion().setFromUnitVectors(axis,target.clone().normalize());
      vec.applyQuaternion(quaternion).multiplyScalar(RADIUS);
      points.push(vec);
    }
    ringsGroup.add(new THREE.LineLoop(new THREE.BufferGeometry().setFromPoints(points), new THREE.LineBasicMaterial({ color })));
  }

  // === Chart.js setup ===
  let chart;
  function updateChart(kt_TNT, mt_TNT) {
    const ctx=document.getElementById("energyChart").getContext("2d");
    if(chart) chart.destroy();
    chart=new Chart(ctx,{
      type:'bar',
      data:{
        labels:["Impacto","Hiroshima (15 kt)","Nagasaki (21 kt)","Tsar Bomba (50 Mt)"],
        datasets:[{
          label:"Megatones TNT",
          data:[mt_TNT,0.015,0.021,50],
          backgroundColor:["#ff6600","#00ccff","#0099ff","#ff3333"]
        }]
      },
      options:{
        responsive:false,
        scales:{
          y:{ 
            type:'logarithmic',
            min:0.001,
            title:{display:true,text:"Megatones TNT (escala log)"}
          }
        }
      }
    });
  }

  // === Simulaci√≥n ===
  function simulateMeteor(lat,lon,d_m,rho,v_kms,eficiencia,depth_km) {
    ringsGroup.clear();
    const v_ms=v_kms*1000;
    const res=mwEquivalente(d_m,rho,v_ms,eficiencia);
    const Mw=res.Mw;
    const umbrales=[6,7,8,9];
    const radios=umbrales.map(mmi=>radioParaMMI(Mw,mmi,depth_km));
    const kt_TNT=res.E_k/4.184e12;
    const mt_TNT=res.E_k/4.184e15;

    document.getElementById("results").innerHTML=`
      <b>Resultados:</b><br>
      Masa: ${res.masa.toExponential(3)} kg<br>
      Energ√≠a cin√©tica: ${res.E_k.toExponential(3)} J<br>
      ‚Üí ${kt_TNT.toFixed(2)} kilotones TNT<br>
      ‚Üí ${mt_TNT.toFixed(4)} megatones TNT<br>
      Energ√≠a s√≠smica: ${res.E_s.toExponential(3)} J<br>
      Mw equivalente: ${Mw.toFixed(2)}<br>
      Radios MMI:<br>
      VI ‚â• ${radios[0]?radios[0].toFixed(1)+" km":"‚Äî"}<br>
      VII ‚â• ${radios[1]?radios[1].toFixed(1)+" km":"‚Äî"}<br>
      VIII ‚â• ${radios[2]?radios[2].toFixed(1)+" km":"‚Äî"}<br>
      IX ‚â• ${radios[3]?radios[3].toFixed(1)+" km":"‚Äî"}<br>
    `;
    updateChart(kt_TNT, mt_TNT);

    const target=latLonToVector3(lat,lon,RADIUS);
    meteoro.position.copy(target.clone().normalize().multiplyScalar(3));
    meteoro.visible=true;
    meteoroGlow.visible=true;
    meteoroGlow.position.copy(meteoro.position);

    flash.visible=false;
    let progress=0,duration=150;

    function fall(){
      if(progress<duration){
        progress++;
        meteoro.position.lerpVectors(target.clone().normalize().multiplyScalar(3), target, progress/duration);
        meteoroGlow.position.copy(meteoro.position);
        meteoroGlow.material.opacity = 0.9 - (progress/duration)*0.5;
        requestAnimationFrame(fall);
      } else {
        meteoro.visible=false;
        meteoroGlow.visible=false;

        // Flash expansivo
        flash.position.copy(target.clone().multiplyScalar(1.02));
        flash.visible=true;
        flash.scale.setScalar(0.5);
        flash.material.opacity=1.0;

        let flashProgress=0;
        function expandFlash(){
          if(flashProgress<50){
            flashProgress++;
            const t=flashProgress/50;
            flash.scale.setScalar(0.5+t*5);
            flash.material.opacity=1.0-t;
            requestAnimationFrame(expandFlash);
          } else {
            flash.visible=false;
          }
        }
        expandFlash();

        // Luz nuclear
        const impactLight=new THREE.PointLight(0xffffff,10,10);
        impactLight.position.copy(target.clone().multiplyScalar(1.05));
        scene.add(impactLight);

        let lightProgress=0;
        function fadeLight(){
          if(lightProgress<100){
            lightProgress++;
            impactLight.intensity=10*(1-lightProgress/100);
            requestAnimationFrame(fadeLight);
          } else {
            scene.remove(impactLight);
          }
        }
        fadeLight();

        // Brillo blanco de la Tierra
        const baseColor=new THREE.Color(0x2266ff);
        const white=new THREE.Color(0xffffff);
        let earthProgress=0;
        function flashEarth(){
          if(earthProgress<100){
            earthProgress++;
            const t=earthProgress/100;
            if(t<0.5){
              earth.material.color.lerpColors(baseColor,white,t*2);
            } else {
              earth.material.color.lerpColors(white,baseColor,(t-0.5)*2);
            }
            requestAnimationFrame(flashEarth);
          } else {
            earth.material.color.copy(baseColor);
          }
        }
        flashEarth();

        // Dibujar anillos s√≠smicos
        drawRing(lat,lon,radios[0],0xffff00);
        drawRing(lat,lon,radios[1],0xff9900);
        drawRing(lat,lon,radios[2],0xff3300);
        drawRing(lat,lon,radios[3],0xff0000);
      }
    }
    fall();
  }

  // === Animaci√≥n general ===
  function animate() {
    requestAnimationFrame(animate);
    earth.rotation.y+=0.0015;
    atmosphere.rotation.y+=0.0015; // atm√≥sfera acompa√±a
    controls.update();
    renderer.render(scene,camera);
  }
  animate();

  document.getElementById("simulateBtn").addEventListener("click",()=>{
    const lat=parseFloat(document.getElementById("lat").value);
    const lon=parseFloat(document.getElementById("lon").value);
    const d_m=parseFloat(document.getElementById("diam").value);
    const rho=parseFloat(document.getElementById("rho").value);
    const v_kms=parseFloat(document.getElementById("vel").value);
    const eff=parseFloat(document.getElementById("eff").value);
    const depth=parseFloat(document.getElementById("depth").value);
    simulateMeteor(lat,lon,d_m,rho,v_kms,eff,depth);
  });

  window.addEventListener("resize",()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
